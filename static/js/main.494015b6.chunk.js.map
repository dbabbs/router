{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["hereCredentials","geocodeUrl","query","concat","routeUrl","start","end","mode","App","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","newRow","copy","assign","state","table","push","provider","shape","setState","editRow","val","row","col","go","asyncToGenerator","regenerator_default","a","mark","_callee3","geocodePromises","geocoded","routePromises","routes","geojson","element","file","wrap","_context3","prev","next","console","log","map","_ref2","_callee","i","_context","fetch","then","res","json","sent","startCoordinates","Response","View","Result","Location","NavigationPosition","endCoordinates","abrupt","stop","_x","_x2","apply","arguments","Promise","all","_ref3","_callee2","path","_context2","Latitude","Longitude","response","route","length","x","vals","split","Number","_x3","_x4","type","features","r","geometry","coordinates","properties","startAddress","endAddress","document","createElement","Blob","JSON","stringify","href","URL","createObjectURL","download","body","appendChild","click","_this2","grid","gridTemplateColumns","keys","react_default","className","onClick","key","style","z","q","value","onChange","evt","target","React","Component","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.494015b6.chunk.js","sourcesContent":["import React from 'react';\nimport './App.css';\n\nconst hereCredentials = {\n   id: 'UQ75LhFcnAv0DtOUwBEA',\n   code: 'f5nyezNmYF4wvuJqQgNSkg'\n}\n\nconst geocodeUrl = (query) => `https://geocoder.api.here.com/6.2/geocode.json?app_id=${hereCredentials.id}&app_code=${hereCredentials.code}&searchtext=${query}`;\nconst routeUrl = (start, end, mode) => `https://route.api.here.com/routing/7.2/calculateroute.json?app_id=${hereCredentials.id}&app_code=${hereCredentials.code}&waypoint0=geo!${start}&waypoint1=geo!${end}&mode=fastest;${mode};traffic:disabled&routeattributes=shape`\nclass App extends React.Component {\n   constructor(props) {\n      super(props);\n      this.state = {\n         table: [\n            {\n               start: '701 Pike St. Seattle',\n               end: '954 E Union St. Seattle',\n               provider: 'uber',\n               mode: 'pedestrian',\n               shape: []\n            }\n         ]\n      }\n   }\n\n   newRow = () => {\n      const copy = Object.assign(this.state.table, {});\n      copy.push({\n         start: '', end: '', provider: '', mode: 'pedestrian', shape: []\n      });\n      this.setState({\n         table: copy\n      });\n   }\n\n   editRow = (val, row, col) => {\n      const table = Object.assign(this.state.table, {});\n      table[col][row] = val;\n      this.setState({ table })\n   }\n\n   go = async () => {\n      console.log('click')\n      const geocodePromises = this.state.table.map(async (row, i) => {\n         const start = await fetch(geocodeUrl(row.start)).then(res => res.json());\n         const end = await fetch(geocodeUrl(row.end)).then(res => res.json());\n         // console.log(sxtart);\n         row.startCoordinates = start.Response.View[0].Result[0].Location.NavigationPosition[0];\n         row.endCoordinates = end.Response.View[0].Result[0].Location.NavigationPosition[0];\n         return row;\n      })\n\n      const geocoded = await Promise.all(geocodePromises);\n\n\n      const routePromises = geocoded.map(async (row, i) => {\n         const path = await fetch(\n            routeUrl(\n               row.startCoordinates.Latitude + ',' + row.startCoordinates.Longitude,\n               row.endCoordinates.Latitude + ',' + row.endCoordinates.Longitude,\n               row.mode\n            )\n         ).then(res => res.json())\n         .then(res => {\n            console.log(res.response.route[0].shape.length)\n            return res.response.route[0].shape.map(x => {\n               \n               const vals = x.split(',');\n               return [Number(vals[1]), Number(vals[0])]\n            });\n         })\n         row.shape = path;\n         return row;\n      });\n      const routes = await Promise.all(routePromises);\n      console.log(routes);\n\n      const geojson = {\n         type: 'FeatureCollection',\n         features: routes.map(r => {\n            return {\n               geometry: {\n                  type: 'LineString',\n                  coordinates: r.shape\n               },\n               type: 'Feature',\n               properties: {\n                  provider: r.provider,\n                  startAddress: r.start,\n                  endAddress: r.end,\n                  mode: r.mode\n               }\n            }\n         })\n      }\n\n\n      const element = document.createElement(\"a\");\n      const file = new Blob([JSON.stringify(geojson)], {type: 'text/plain'});\n      element.href = URL.createObjectURL(file);\n      element.download = \"routes.geojson\";\n      document.body.appendChild(element); // Required for this to work in FireFox\n      element.click();\n      // console.log(table2);\n   \n   }\n\n\n   render() {\n      const grid = {gridTemplateColumns: `repeat(${Object.keys(this.state.table[0]).length}, 1fr)`}\n      return (\n         <div className=\"app\">\n            <button onClick={this.newRow}>New row</button>\n            <button onClick={this.go}>Route</button>\n            {\n               this.state.table.map((row, i) => {\n                  return (\n                     <div className=\"row\" key={i} style={grid}>\n                        {\n                           Object.keys(row).map((z, q) => {\n                              return (\n                                 <input\n                                    key={q}\n                                    type=\"text\"\n                                    value={row[z]}\n                                    onChange={(evt) => this.editRow(evt.target.value, z, i)}\n                                 />\n                              )\n                           })\n                        }\n                     </div>\n                  )\n               })\n            }\n         </div>\n      )\n   }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}